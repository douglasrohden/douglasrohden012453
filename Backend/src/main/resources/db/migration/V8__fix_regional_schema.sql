-- V8: Fix regional schema to match JPA entity + edital rules
-- - Adds external_id (required)
-- - Ensures id is auto-generated for inserts (IDENTITY or sequence default)
-- - Enforces: only one active row per external_id (partial unique index)

-- 1) Add external_id column if missing
ALTER TABLE IF EXISTS regional
  ADD COLUMN IF NOT EXISTS external_id INTEGER;

-- 2) Backfill existing rows (legacy schema used id as external identifier)
UPDATE regional
SET external_id = id
WHERE external_id IS NULL;

-- 3) Ensure external_id is NOT NULL
ALTER TABLE IF EXISTS regional
  ALTER COLUMN external_id SET NOT NULL;

-- 4) Ensure id is BIGINT (matches JPA Long)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'regional'
      AND column_name = 'id'
      AND data_type = 'integer'
  ) THEN
    ALTER TABLE regional ALTER COLUMN id TYPE BIGINT;
  END IF;
END $$;

-- 5) Ensure id is generated on insert (identity preferred; fallback to sequence default)
DO $$
DECLARE
  has_identity boolean;
  has_default  boolean;
BEGIN
  SELECT (is_identity = 'YES')
    INTO has_identity
  FROM information_schema.columns
  WHERE table_schema = 'public'
    AND table_name = 'regional'
    AND column_name = 'id';

  SELECT (column_default IS NOT NULL)
    INTO has_default
  FROM information_schema.columns
  WHERE table_schema = 'public'
    AND table_name = 'regional'
    AND column_name = 'id';

  IF COALESCE(has_identity, false) = false AND COALESCE(has_default, false) = false THEN
    BEGIN
      ALTER TABLE regional ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
    EXCEPTION WHEN others THEN
      IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'regional_id_seq') THEN
        CREATE SEQUENCE regional_id_seq;
      END IF;

      PERFORM setval('regional_id_seq', (SELECT COALESCE(MAX(id), 0) FROM regional), true);
      ALTER TABLE regional ALTER COLUMN id SET DEFAULT nextval('regional_id_seq');
    END;
  END IF;
END $$;

-- 6) If DB already has duplicated active rows per external_id, inactivate all but the newest
WITH ranked AS (
  SELECT id,
         external_id,
         ROW_NUMBER() OVER (PARTITION BY external_id ORDER BY id DESC) AS rn
  FROM regional
  WHERE ativo = TRUE
)
UPDATE regional r
SET ativo = FALSE
FROM ranked
WHERE r.id = ranked.id
  AND ranked.rn > 1;

-- 7) Indexes for sync queries + edital rule (one active per external_id)
CREATE INDEX IF NOT EXISTS idx_regional_external_id
  ON regional (external_id);

CREATE UNIQUE INDEX IF NOT EXISTS uq_regional_external_id_active
  ON regional (external_id)
  WHERE ativo = TRUE;
